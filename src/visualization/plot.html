<!DOCTYPE html>
<html>
<meta charset="utf-8">

<script type="text/javascript" src="springmesh_5_nn_benchmark_data_0.js"></script>
<script type="text/javascript" src="springmesh_5_nn_benchmark_data_1.js"></script>
<script type="text/javascript" src="springmesh_5_nn_benchmark_data.js"></script>

<script type="text/javascript" src="springmesh_3_nn_benchmark_data_0.js"></script>
<script type="text/javascript" src="springmesh_3_nn_benchmark_data.js"></script>

<script type="text/javascript" src="spring_nn_benchmark_data_0.js"></script>
<script type="text/javascript" src="spring_nn_benchmark_data.js"></script>

<script type="text/javascript" src="wave_nn_benchmark_data_0.js"></script>
<script type="text/javascript" src="wave_nn_benchmark_data_1.js"></script>
<script type="text/javascript" src="wave_nn_benchmark_data.js"></script>

<script src="renderjson.js"></script>
<script src="FileSaver.js"></script>
<script src="d3.v3.min.js"></script>


<style>
	body, select, button {
		font: 12pt avenir-light;
	}

	.main-container {
		width: 1200px;
		margin: auto;
	}


	#title {
		font-size: 20pt;
	}


	.axis path,
	.axis line {
		fill: none;
		stroke: grey;
		stroke-width: 1;
		shape-rendering: crispEdges;
	}

	.dot {
		stroke: #000;
	}


	.vis {
		stroke: #000;
	}

	.tooltip {
		position: absolute;
		/*width: 300px;*/
		height: 60px;
		pointer-events: none;
		background-color: white;
	}

	.axis-table th, .axis-table td {
		padding-right: 60px;
		padding-top: 30px;
		text-align: left;
	}

	.legend {
		cursor: pointer;
	}

	.legend-text-off {
		fill: #b2bec3;
	}

	.legend-text {
		fill: black;
	}

	.num-table {
		width: 200px;
		text-align: center;
	}

	#methods {
		padding-left: 30px;
	}

	.bottom-opt {
		padding-left: 10px;
	}

	.top-padding {
		padding-top: 15px;
	}

	.data-div {
		display: inline-block;
		padding-right: 20px;
	}

	.bold {
		font-weight: bold;
	}

	.float-left {
		float: left;
	}

	.small {
		font-size: 8pt;
	}

	.slider-bounding-box{
		padding-top: 20px;
		padding-bottom: 20px;
	}

	.slider {
	  position: relative;
	  /*padding: 10px;*/
	  /*top: 40px;*/
	  /*left: 40px;*/
	}

	.slider-tray {
	  position: absolute;
	  width: 100%;
	  height: 6px;
	  border: solid 1px #ccc;
	  border-top-color: #aaa;
	  border-radius: 4px;
	  background-color: #f0f0f0;
	  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.08);
	}

	.slider-handle {
	  position: absolute;
	  top: 3px;
	  left: 500px;
	}

	.slider-handle-icon {
	  width: 14px;
	  height: 14px;
	  border: solid 1px #aaa;
	  position: absolute;
	  border-radius: 10px;
	  background-color: #fff;
	  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
	  top: -7px;
	  left: -7px;
	}



</style>
<body>
<div class="main-container">
	<div class="float-left">
		<div id="title" class="bold"></div>
		<div class="container" id="plot"></div>
		<div class="container" id="plot_loss"></div>
		<div class="container" id="plot_vis"></div>

		<div class="slider-bounding-box">
			<div class="slider"></div>
		</div>

		<div>
			<div class="data-div">
				<span class="bold">Data</span><div id = "datasDropdown"></div>
			</div>
			<div class="data-div">
				<span class="bold">Problem</span><div id = "problemsDropdown"></div>
			</div>
			

			<div  class="data-div" style="margin-bottom: -16px;">
				<table class="num-table">
					<tr  class="bold">
						<td>TIMESTEP</td>
					</tr>
					<tr>
						<td id = "timestep"></td>
					</tr>
				</table>
			</div>
		</div>
		<table class="axis-table">
			<td>
				<div>
					<span class="bold">X-Axis</span>
					<div id = "xaxisDropdown"></div>
					Log <span id = "xaxisCheckobx"></span>
				</div>
			</td>
			<td>
				<div>
					<span class="bold">Y-Axis</span>
					<div id = "yaxisDropdown"></div>
					Log <span id = "yaxisCheckobx"></span>
				</div>
			</td>
			<td>
				<div>
					<span class="bold">Trajectory Number</span>
					<div id = "trajectoryDropdown"></div>
				</div>
			</td>
		</table>

		<div class="top-padding">
			<button id="generate">Save SVG</button>
		</div>
	</div>
	<div id="methods" class="float-left"></div>
	<pre id="info" class="float-left small"></pre>


	<div id="train_val_loss" class="float-right"></div>

</div>
<script>


var datas = {
    springmesh_5_nn_benchmark_data: springmesh_5_nn_benchmark_data,
    springmesh_3_nn_benchmark_data: springmesh_3_nn_benchmark_data,
    spring_nn_benchmark_data: spring_nn_benchmark_data,
    wave_nn_benchmark_data: wave_nn_benchmark_data,
};

var margin = {top: 20, right: 100, bottom: 50, left: 80};
var width = 960 - margin.left - margin.right;
var height = 500 - margin.top - margin.bottom;

var colors_array_ = {
	"integrator-baseline": [106,61,154],
	"mlp": [166,206,227],
	"hnn": [31,120,180],
	"knn-regressor": [178,223,138],
	"knn-predictor": [51,160,44],
	"knn-regressor-oneshot": [251,154,153],
	"knn-predictor-oneshot": [227,26,28],
	"nn-kernel": [253,191,111],
	"gn": [255,127,0],
	"cnn": [202,178,214],
	"other": [255,255,153]
}

var colors_array = {};
var show_type = {};

datas["springmesh_5_nn_benchmark_data"].forEach(function(d) {
	var o = Math.round, r = Math.random, s = 255;
	if (!(d["method_name"] in colors_array)) {
		var type = d["method_name"] + "-" + d["integrator_name"];
		colors_array[type] = [o(r()*s), o(r()*s), o(r()*s)];
		show_type[type] = true;
	}
});

var colors = {};

for (const [key, value] of Object.entries(colors_array)) {
	colors[key] = 'rgb('+value[0]+', '+value[1]+', '+value[2]+')';
}




var svg = d3.select("#plot").append("svg")
	.attr("width", width + margin.left + margin.right)
	.attr("height", height + margin.top + margin.bottom)
	.append("g")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var svg_loss = d3.select("#plot_loss").append("svg") 
	.attr("width", width + margin.left + margin.right)
	.attr("height", height + margin.top + margin.bottom)
	.append("g")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var svg_vis = d3.select("#plot_vis").append("svg") 
	.attr("width", width + margin.left + margin.right)
	.attr("height", height + margin.top + margin.bottom)
	.append("g")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");


var tooltip = d3.select("body")
	.append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

var datasMenu = d3.select("#datasDropdown")
datasMenu.append("select")
	.selectAll("option")
	.data(Object.keys(datas))
	.enter()
	.append("option")
	.attr("value", function(d){
    	return d;
	})
	.text(function(d){
    	return d;
	});
datasMenu.on('change', function(d){
	var selection = d3.select(this).select("select").property("value")
	load_data(selection);
});

d3.select("#generate").on("click", writeDownloadLink);

function writeDownloadLink(){
	try {
		var isFileSaverSupported = !!new Blob();
	} catch (e) {
		alert("blob not supported");
	}

	var html = d3.select("svg")
	.attr("title", current_name.replace("_"," "))
	.attr("version", 1.1)
	.attr("xmlns", "http://www.w3.org/2000/svg");

	html.append("style")
	.text(
		"* {\n"+
		"font: 14pt avenir-light;\n"+
		"}\n"+
		".axis path,\n"+
		".axis line {\n"+
		"fill: none;\n"+
		"stroke: #000;\n"+
		"shape-rendering: crispEdges;\n"+
		"}\n"+
		"\n"+
		".dot {\n"+
		"stroke: #000;\n"+
		"}\n"+
		".legend-text {\n"+
		"fill: black;\n"+
		"}\n");


	html = html.node().parentNode.innerHTML;



	var blob = new Blob([html], {type: "image/svg+xml"});
	saveAs(blob, current_name+"_"+currentXAxis+"_"+currentYAxis+currentProblem+".svg");
};

var legend = svg.selectAll(".legend")
.data(Object.keys(colors_array))
.enter().append("g")
.attr("class", "legend")
.attr("transform", function(d, i) { return "translate(100," + i * 20 + ")"; })
.on('click', function(d) {
	show_type[d] = !show_type[d];

	var n = d3.select(this);
	n.attr('class', function(){ return show_type[d] ? "legend-text" : "legend-text-off"; });

	updateAxis();
	reload();
 });


legend.append("rect")
.attr("x", width - 18)
.attr("width", 18)
.attr("height", 18)
.style("fill", function(d) { return colors[d];});

// draw legend text
legend.append("text")
.attr("x", width - 24)
.attr("y", 9)
.attr("dy", ".35em")
.style("text-anchor", "end")
.text(function(d) { return d;})


var data = [];
var loss_data = [];
var current_name = "";
var currentProblem = "base";
var currentXAxis = "integration_time";
var currentYAxis = "mse";
var num_traj = 0;

var currentXAxisLog = true;
var currentYAxisLog = true;

var xScale = {};
var yScale = {};
var xAxis = {};
var yAxis = {};

var loss_xScale = {};
var lloss_yScale = {};
var rloss_yScale = {};
var loss_xAxis = {};
var lloss_yAxis = {};
var rloss_yAxis = {};

var vis_xScale = {};
var vis_yScale = {};
var vis_xAxis = {};
var vis_yAxis = {};

var vis_data = {gt: [], inf: []};

var max_timestep = 1;
var timestep = 1;
var timestep_difference = 1;

load_data('springmesh_5_nn_benchmark_data');


function updateTimestep()
{
	timestep /= max_timestep;
	found = false;
	data.forEach(function (d) {
		if (d["problem"] == currentProblem && !found) {
			max_timestep = d[currentYAxis].length - 1;
			timestep_difference = (max_timestep + 1)/(d["ground_truth_data"][num_traj].length);
			found = true;
		}
	});
	timestep *= max_timestep;
	timestep = Math.trunc(timestep);
}


function updateAxis()
{
	xScale = currentXAxisLog ? d3.scale.log().range([0, width]) : d3.scale.linear().range([0, width]);
	yScale = currentYAxisLog ? d3.scale.log().range([height, 0]): d3.scale.linear().range([height, 0]);

	xAxis = d3.svg.axis().scale(xScale).orient("bottom");
	yAxis = d3.svg.axis().scale(yScale).orient("left");
}


function reload()
{
    var filterFunc = function(d) {
        if(d[currentXAxis] == null || d[currentYAxis] == null)
            return false;

		var type = d["method_name"] + "-" + d["integrator_name"];
		if (!show_type[type]) {
			return false;
		}

        if (!(d["problem"] == currentProblem))
        	return false;
        
        return true;
    }

	var xData = [];
	var yData = [];

    data_ = data.filter(filterFunc);
    data_.forEach(function(d) {
    	var val_x = d[currentXAxis]
    	if (val_x.constructor === Array) {
	        val_x = val_x[timestep];
    	}

		var val_y = d[currentYAxis]
    	if (val_y.constructor === Array) {
	        val_y = val_y[timestep];
    	}

        xData.push(val_x);
        yData.push(val_y);
    });


	d3.select("#timestep").text(timestep);

	xScale.domain([d3.min(xData), d3.max(xData)]);
	yScale.domain([d3.min(yData), d3.max(yData)]);

	svg.selectAll('.seg').remove()
	svg.selectAll('.dot').remove()
	svg.selectAll('.axis').remove()


	// x-axis
	svg.append("g")
	.attr("class", "x axis")
	.attr("transform", "translate(0," + height + ")")
	.call(xAxis)
	.append("text")
	.attr("class", "label")
	.attr("x", width)
	.attr("y", margin.bottom -5)
	.style("text-anchor", "end")
	.text(currentXAxis.split("_").join(" "));

	// y-axis
	svg.append("g")
	.attr("class", "y axis")
	.call(yAxis)
	.append("text")
	.attr("class", "label")
	.attr("transform", "rotate(-90)")
	.attr("y", -margin.left)
	// .attr("x", margin.top)
	.attr("dy", ".71em")
	.style("text-anchor", "end")
	.text(currentYAxis.split("_").join(" "));

	svg.append("g").attr("class", "dot").selectAll(".dot")
	.data(data)
	.enter().append("circle")
	.filter(filterFunc)
	.attr("class", "dot")
	.attr("r", 3.5)
	.attr("cx", function(d) { 
		var val_x = d[currentXAxis]
    	if (val_x.constructor === Array) {
    		console.log(timestep);
	        val_x = val_x[timestep];
    	}
    	return xScale(val_x);
	})
	.attr("cy", function(d) { 
		var val_y = d[currentYAxis]
    	if (val_y.constructor === Array) {
	        val_y = val_y[timestep];
    	}
    	return yScale(val_y);
	})
	.style("stroke", "none")
	.style("fill", function(d) {
		var type = d["method_name"] + "-" + d["integrator_name"];
		return colors[type];
	})
	.on("mouseover", function(d) {
		tmp = d["experiment_name"].split("/");
		tmp = tmp[tmp.length-1];
		val_x = d[currentXAxis]
		val_y = d[currentYAxis]
		if (val_x.constructor === Array)
			val_x = val_x[timestep]
		if (val_y.constructor === Array)
			val_y = val_y[timestep]
        console.dir(val_x);
        console.dir(val_y);
		tooltip.transition()
		.duration(200)
		.style("opacity", 1);
		tooltip.html(tmp + "<br/> " +
			"(" + val_x.toExponential(3) + ", " + val_y.toExponential(3) + ")")
		.style("left", (d3.event.pageX + 5) + "px")
		.style("top", (d3.event.pageY - 28) + "px");
	})
	.on("mouseout", function(d) {
		tooltip.transition()
		.duration(500)
		.style("opacity", 0);
	})
	.on("click", function(d) {
		// Plot the training and validation losses on the side
		svg_loss.selectAll('.axis').remove()
		svg_loss.selectAll('path').remove()
		svg_vis.selectAll('vis').remove()
		svg_vis.selectAll('.axis').remove()



		if (!(d["train_loss"] == null) && !(d["val_loss"] == null)) {


			loss_xScale = d3.scale.linear().range([0, width]).domain([0, d["train_loss"].length]);
			lloss_yScale = d3.scale.log().range([height, 0]).domain([d3.min(d["train_loss"]), d3.max(d["train_loss"])]);
			rloss_yScale = d3.scale.log().range([height, 0]).domain([d3.min(d["val_loss"]), d3.max(d["val_loss"])]);

			loss_xAxis = d3.svg.axis().scale(loss_xScale).orient("bottom");
			lloss_yAxis = d3.svg.axis().scale(lloss_yScale).orient("left");
			rloss_yAxis = d3.svg.axis().scale(rloss_yScale).orient("right");

			svg_loss.append("g")
			.attr("class", "x axis")
			.attr("transform", "translate(0," + height + ")")
			.call(loss_xAxis)
			.append("text")
			.attr("class", "label")
			.attr("x", width)
			.attr("y", margin.bottom -5)
			.style("text-anchor", "end")
			.text("iteration");

			// y-axis
			svg_loss.append("g")
			.attr("class", "y axis")
			.call(lloss_yAxis)
			.append("text")
			.attr("class", "label")
			.attr("transform", "rotate(-90)")
			.attr("y", -margin.left)
			// .attr("x", margin.top)
			.attr("dy", ".71em")
			.style("text-anchor", "end")
			.text("Train Loss");


			svg_loss.append("g")
			.attr("class", "y axis")
			.attr("transform", "translate(" + width + " ,0)")
			.call(rloss_yAxis)
			.append("text")
			.attr("class", "label")
			.attr("transform", "rotate(-90)")
			.attr("y", margin.left)
			// .attr("x", margin.top)
			.attr("dy", ".71em")
			.style("text-anchor", "end")
			.text("Val Loss");

			loss_data = [];
			 //{x: Array(d["train_loss"].length).keys(), y: d["train_loss"]};
			for (i of Array(d["train_loss"].length).keys()) {
				loss_data.push({x: i, y: d["train_loss"][i]});
			}

			svg_loss.append("path")
			.datum(loss_data)
			.attr("fill", "none")
			.attr("stroke", "steelblue")
			.attr("stroke-width", 1.5)
			.attr("d", d3.svg.line()
				.x(function(d) { return loss_xScale(d.x) })
				.y(function(d) { return lloss_yScale(d.y) }));

			loss_data = [];
			 //{x: Array(d["train_loss"].length).keys(), y: d["train_loss"]};
			for (i of Array(d["val_loss"].length).keys()) {
				loss_data.push({x: i, y: d["val_loss"][i]});
			}

			svg_loss.append("path")
			.datum(loss_data)
			.attr("fill", "none")
			.attr("stroke", "red")
			.attr("stroke-width", 1.5)
			.attr("d", d3.svg.line()
				.x(function(d) { return loss_xScale(d.x) })
				.y(function(d) { return rloss_yScale(d.y) }));
		}


		vis_data = {gt: [], inf: []};

		if (!(d["inferred_data"] == null) && !(d["ground_truth_data"] == null)) {
			if (current_name.includes("wave")) {
				vis_xScale = d3.scale.linear().range([0, width]).domain([-0.1, 1.1]);
				vis_yScale = d3.scale.linear().range([height, 0]).domain([-2, 2]);
			} else if (current_name.includes("springmesh")) {
				vis_xScale = d3.scale.linear().range([0, width]).domain([-1, 5]);
				vis_yScale = d3.scale.linear().range([height, 0]).domain([-1, 5]);
            } else {
				vis_xScale = d3.scale.linear().range([0, width]).domain([-1, 5]);
				vis_yScale = d3.scale.linear().range([height, 0]).domain([-1, 5]);
            }

			vis_xAxis = d3.svg.axis().scale(vis_xScale).orient("bottom");
			vis_yAxis = d3.svg.axis().scale(vis_yScale).orient("left");

			svg_vis.append("g")
			.attr("class", "x axis")
			.attr("transform", "translate(0," + height + ")")
			.call(vis_xAxis)
			.append("text")
			.attr("class", "label")
			.attr("x", width)
			.attr("y", margin.bottom -5)
			.style("text-anchor", "end")
			.text("x");

			// y-axis
			svg_vis.append("g")
			.attr("class", "y axis")
			.call(vis_yAxis)
			.append("text")
			.attr("class", "label")
			.attr("transform", "rotate(-90)")
			.attr("y", -margin.left)
			// .attr("x", margin.top)
			.attr("dy", ".71em")
			.style("text-anchor", "end")
			.text("y");



			console.dir(d["inferred_data"][num_traj]);

			if (current_name.includes("wave")) {
				for (i of Array(d["ground_truth_data"][num_traj].length).keys()) {
					var step_vis_data = [];
					var x_coord = 0;
					for (j of d["ground_truth_data"][num_traj][i]) {
						step_vis_data.push({x: x_coord, y: j[1]}); 
						x_coord += (1./125.);
					}
					vis_data["gt"].push(step_vis_data);
				}

				for (i of Array(d["inferred_data"][num_traj].length).keys()) {
					var step_vis_data = [];
					var x_coord = 0;
					for (j of d["inferred_data"][num_traj][i]) {
						step_vis_data.push({x: x_coord, y: j[1]}); 
						x_coord += (1./125.);
					}
					vis_data["inf"].push(step_vis_data);
				}
			} else {
				for (i of Array(d["ground_truth_data"][num_traj].length).keys()) {
					var step_vis_data = [];
					for (j of d["ground_truth_data"][num_traj][i]) {
						step_vis_data.push({x: j[0][1], y: j[1][1]}); 
					}
					vis_data["gt"].push(step_vis_data);
				}

				for (i of Array(d["inferred_data"][num_traj].length).keys()) {
					var step_vis_data = [];
					for (j of d["inferred_data"][num_traj][i]) {
						step_vis_data.push({x: j[0][1], y: j[1][1]}); 
					}
					vis_data["inf"].push(step_vis_data);
				}
			} 

			var curr_step = Math.trunc(timestep / timestep_difference);

			svg_vis
			.attr("class", "vis")
			.selectAll(".vis")
			.data(vis_data["inf"][curr_step])
			.enter()
			.append("circle")
			.attr("class", "vis")
			.attr("fill", "steelblue")
			.attr("r", 4.5)
			.attr("cx", function(d) { 
				return vis_xScale(d.x) })
			.attr("cy", function(d) { 
				return vis_yScale(d.y) });

			// svg_vis
			// .attr("class", "vis_")
			// .selectAll(".vis")
			// .data(vis_data["inf"][curr_step])
			// .enter()
			// .append("circle")
			// .attr("class", "vis")
			// .attr("fill", "red")
			// .attr("r", 3.5)
			// .attr("cx", function(d) { 
			// 	return vis_xScale(d.x) })
			// .attr("cy", function(d) { 
			// 	return vis_yScale(d.y) });
		}


	});


	if (vis_data["inf"].length != 0) {
		svg_vis.selectAll('.vis').remove()

		var curr_step = Math.trunc(timestep / timestep_difference);

		console.dir(curr_step);

		svg_vis
		.attr("class", "vis")
		.selectAll(".vis")
		.data(vis_data["inf"][curr_step])
		.enter()
		.append("circle")
		.attr("class", "vis")
		.attr("fill", "steelblue")
		.attr("r", 4.5)
		.attr("cx", function(d) { 
			return vis_xScale(d.x) })
		.attr("cy", function(d) { 
			return vis_yScale(d.y) });

		// svg_vis
		// .attr("class", "vis_")
		// .selectAll(".vis")
		// .data(vis_data["inf"][curr_step])
		// .enter()
		// .append("circle")
		// .attr("class", "vis")
		// .attr("fill", "red")
		// .attr("r", 3.5)
		// .attr("cx", function(d) { 
		// 	return vis_xScale(d.x) })
		// .attr("cy", function(d) { 
		// 	return vis_yScale(d.y) });
	}

}



// load data
function load_data(name)
{
	current_name = name
	data = datas[current_name];

	tmp = [];

    data.forEach(function(d) {
        // if (d["experiment_name"].includes("springmesh"))
        //     tmp.push("springmesh")
        // else if (d["experiment_name"].includes("spring"))
        //     tmp.push("spring")
        // else if (d["experiment_name"].includes("wave"))
        //     tmp.push("wave")
        tmp.push(d["problem"])
    });

    var tmpk = Object.keys(data[0]);
    var keys = tmpk.filter(function(d) {
    	if (data[0][d] == null) {
    		return false;
    	}
    	if ((d == "train_loss") || (d == "val_loss") || (d == "ground_truth_data") || (d == "inferred_data"))
    		return false;
    	else if ((data[0][d].constructor === Array) || (typeof data[0][d] === "number"))
    		return true;
    	else
	    	return false;
    });
    keys.sort();

    var problems = Array.from(new Set(tmp));
	
	if(currentProblem.length <= 0)
	{
		currentProblem = tmp[0];
	}

	var xindex = -1;
	var yindex = -1;

	for(var i = 0; i < keys.length; ++i)
	{
		if(keys[i] == currentXAxis)
			xindex = i;
		if(keys[i] == currentYAxis)
			yindex = i;
	}

	var problemIndex = 0;
	for(var i = 0; i < problems.length; ++i)
	{
		if(problems[i] == currentProblem){
			problemIndex = i;
			break;
		}
	}

	d3.select("#title").text(current_name.replace("_"," "));


	var problemsMenu = d3.select("#problemsDropdown")
	problemsMenu.selectAll("select").remove();

    problemsMenu.append("select")
    	.selectAll("option")
        .data(problems)
        .enter()
        .append("option")
        .attr("value", function(d){
            return d;
        })
        .text(function(d){
            return d;
        });
    d3.select("#problemsDropdown").select("select").property("selectedIndex", problemIndex);

    problemsMenu.on('change', function(d){
    	var selection = d3.select(this).select("select").property("value")

    	currentProblem = selection;
    	console.dir(currentProblem);

    	updateTimestep();
    	reload();
    });


    var xaxisMenu = d3.select("#xaxisDropdown")
    xaxisMenu.selectAll("select").remove();
    xaxisMenu.append("select")
    	.selectAll("option")
        .data(keys)
        .enter()
        .append("option")
        .attr("value", function(d){
            return d;
        })
        .text(function(d){
            return d.split("_").join(" ");
        });
    d3.select("#xaxisDropdown").select("select").property("selectedIndex", xindex);
    xaxisMenu.on('change', function(d){
    	var selection = d3.select(this).select("select").property("value")
    	currentXAxis = selection;

    	reload();
    });

    var yaxisMenu = d3.select("#yaxisDropdown")
    yaxisMenu.selectAll("select").remove();
    yaxisMenu.append("select")
    	.selectAll("option")
        .data(keys)
        .enter()
        .append("option")
        .attr("value", function(d){
            return d;
        })
        .text(function(d){
            return d.split("_").join(" ");
        });
    d3.select("#yaxisDropdown").select("select").property("selectedIndex", yindex);
    yaxisMenu.on('change', function(d){
    	var selection = d3.select(this).select("select").property("value")
    	currentYAxis = selection;

    	reload();
    });


	// var trajectoryMenu = d3.select("#trajectoryDropdown")
	//     trajectoryMenu.selectAll("select").remove();
	//     trajectoryMenu.append("select")
	//     	.selectAll("option")
	//         .data(Array.from(Array(30).keys()))
	//         .enter()
	//         .append("option")
	//         .attr("value", function(d){
	//             return d;
	//         });
	//     d3.select("#trajectoryDropdown").select("select").property("selectedTrajectory", num_traj);
	//     trajectoryMenu.on('change', function(d){
	//     	var selection = d3.select(this).select("select").property("value")
	//     	num_traj = selection;

	//     	reload();
	//     });


    updateTimestep();
    updateAxis();
	reload();
}


var xaxisCheckobx = d3.select("#xaxisCheckobx")
xaxisCheckobx.selectAll("input").remove();
xaxisCheckobx.append("input")
	.property("checked", currentXAxisLog)
	.attr("id", "xaxislog")
	.attr("type", "checkbox");
xaxisCheckobx.on('change', function(d) {
	var val = d3.select(this).select("input").property("checked")
	currentXAxisLog = val;
	updateAxis();
	reload();
});


var yaxisCheckobx = d3.select("#yaxisCheckobx")
yaxisCheckobx.selectAll("input").remove();
yaxisCheckobx.append("input")
	.property("checked", currentYAxisLog)
	.attr("id", "yaxislog")
	.attr("type", "checkbox");
yaxisCheckobx.on('change', function(d){
	var val = d3.select(this).select("input").property("checked")
	currentYAxisLog = val;
	updateAxis();
	reload();
});


var slider_width = 500;

var x = d3.scale.linear()
    .domain([1, 100])
    .range([0, slider_width])
    .clamp(true);

var dispatch = d3.dispatch("sliderChange", "sliderEnd");

var slider = d3.select(".slider")
    .style("width", slider_width + "px");

var sliderTray = slider.append("div")
    .attr("class", "slider-tray");

var sliderHandle = slider.append("div")
    .attr("class", "slider-handle");

sliderHandle.append("div")
    .attr("class", "slider-handle-icon")

slider.call(d3.behavior.drag()
    .on("dragstart", function() {
      dispatch.sliderChange(x.invert(d3.mouse(sliderTray.node())[0]));
      d3.event.sourceEvent.preventDefault();
    })
    .on("drag", function() {
      dispatch.sliderChange(x.invert(d3.mouse(sliderTray.node())[0]));
    })
    .on("dragend", function() {
      dispatch.sliderEnd(x.invert(d3.mouse(sliderTray.node())[0]));
    }));

dispatch.on("sliderChange.slider", function(value) {
  sliderHandle.style("left", x(value) + "px");
});

dispatch.on("sliderEnd.slider", function(value) {
	timestep = Math.trunc((value * max_timestep) / 100.);
	updateAxis();
	reload();
});


</script>
</body>
</html>
